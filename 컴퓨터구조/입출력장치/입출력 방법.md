# 컴퓨터구조
---
## 입출력장치
---
### 프로그램 입출력
```
기본적으로 프로그램 속 명령어로 입출력장치를 제어하는 방법
```
CPU가 프로그램 속 명령어를 실행하는 과정에서 입출력 명령어를 만나면 CPU는 입출력장치에 연결된 장치 컨트롤러와 상호작용하며 입출력 작업을 수행한다

프로그램 입출력 방식에서의 입출력 작업은 CPU가 장치 컨트롤러의 레지스터 값을 읽고 씀으로써 이루어진다

CPU 내부에 있는 레지스터들과는 달리 CPU는 여러 잗ㅇ치 컨트롤러 속 레지스터들을 모두 알고 있기 어렵다

명령어들은 어떻게 명령어로 표현되고, 메모리에 어떻게 저장되어 있을까?
`메모리 맵 입출력`과 `고립형 입출력` 크게 두 가지 방식이 있다

#### 메모리 맵 입출력
```
메모리에 접근하기 위한 주소 공간과 입출력장치에 접근하기 위한 주소 공간을 
하나의 주소 공간으로 간주하는 입출력 방식
```

이때 메모리 앱출력 방식에서 CPU는 메모리의 주소들이나 장치 컨트롤러의 레지스터들이나 모두 똑같이 메모리 주소를 대하듯 하면 된다는 점이다
그래서 메모리에 접근하는 명령어와 입출력장치에 접근하는 명령어는 굳이 다를 필요가 없다

#### 고립형 입출력
```
메모리를 위한 주소 공간과 입출력 장치를 위한 주소 공간을 분리하는 방법
```

고립형 입출력 방식에서 CPU는 입출력장치에 접근하기 위해 메모리에 접근하는 명령어와는 다른(입출력 읽기/쓰기 선을 활성화시키는) 입출력 명령어를 사용한다

|메모리 맵 입출력|고립형 입출력|
|:-----:|:-----:|
|메모리와 입출력장치는 같은 주소 공간 사용|메모리와 입출력장치는 분리된 주소 공간 사용|
|메모리 주소 공간이 축소됨|메모리 주소 공간이 축소되지 않음|
|메모리와 입출력장치에 같은 명령어 사용 가능|입출력 전용 명령어 사용|

---
### 인터럽트 기반 입출력
```
인터럽트를 기반으로 하는 입출력
```

여러 입출력장치에서 인터럽트가 동시에 발생한 경우에는 인터럽트들을 어떻게 처리할까?

간단하게 생각하면 인터럽트가 발생한 순서대로 인터럽트를 처리하는 방법이 있다
CPU가 플래그 레지스터 속 인터럽트 비트를 비활성화한 채 인터럽트를 처리하는 경우 다른 입출력 장치에 의한 하드웨어 인터럽트를 받아들이지 않기 때문에 CPU는 이렇듯 순차적으로 하드웨어 인터럽트를 처리하게 된다

하지만 현실적으로 모든 인터럽트를 전부 순차적으로만 해결살수는 없다
CPU는 인터럽트 간에 `우선순위를 고려`하여 우선순위가 높은 인터럽트 순으로 여러 인터럽트를 처리할 수 있다

플래그 레지스터 속 인터럽트 비트가 활성화되어 있는 경우, 혹은 인터럽트 비트를 비활성화해도 무시할 수 없는 인터럽트인 `NMI`가 발생한 경우 CPU는 이렇게 우선순위가 높은 인터럽트부터 처리한다

우선순위를 반영하여 다중 인터럽트를 처리하는 방법에는 여러 가지가 있지만, 많은 컴퓨터에서는 `프로그래머블 인터럽트 컨트롤러(이하 PIC)`라는 하드웨어를 사용한다
> PIC : 여러 장치 컨트롤러에 연결되어 장치 컨트롤러에서 보낸 하드웨어 인터럽트 요청들의 우선순위를 판별한 뒤 CPU에 지금 처리해야 할 하드웨어 인터럽트는 무엇인지를 알려주는 장치

PIC에 연결된 장치 컨트롤러들이 동시에 하드웨어 인터럽트 요청을 보내면 PIC는 이들의 우선순위를 판단하여 CPU에 가장 먼저 처리할 인터럽트를 알려준다

PIC의 다중 인터럽트 처리 과정
```
1. PIC가 장치 컨트롤러에서 `인터럽트 요청 신호(들)`를 받아들인다
2. PIC는 인터럽트 우선순위를 판단한 뒤 CPU에 처리해야 할 `인터럽트 요청 신호`를 보낸다
3. CPU는 PIC에 `인터럽트 확인 신호`를 보낸다
4. PIC는 데이터 버스를 통해 CPU에 `인터럽트 백터`를 보낸다
5. CPU는 인터럽트 백터를 통해 인터럽트 요청의 주체를 알게 되고, 해당 장치의 `인터럽트 서비스 루틴`을 실행한다
```

---
### DMA 입출력
```
CPU를 거치지 않고 메모리와 입출력장치간의 데이터를 주고받는 입출력 방식
```

프로그램 기반 입출력과 인터럽트 기반 입출력에 공통점이 있다면 입출력장치와 메모리 간의 데이터 이동은 CPU가 주도하고, 이동하는 데이터도 반드시 CPU를 거친다는 점이다
입출력장치와 메모리 사이에 전송되는 모든 데이터가 반드시 CPU를 거쳐야 한다면 가뜩이나 바쁜 CPU는 입출력장치를 위한 연산 때문에 시간을 뺏기게 된다
그래서 입출력장치와 메모리가 CPU를 거치지 않고도 상호작용할 수 있는 `DMA`가 등장했다

DMA 입출력을 하기 위해서는 시스템 버스에 연결된 `DMA 컨트롤러`라는 하드웨어가 필요하다

#### DMA 입출력 과정
1. CPU는 DMA 컨트롤러에 입출력장치의 주소, 수행할 연산(읽기/쓰기), 읽거나 쓸 메모리의 주소 등과 같은 정보로 입출력 작업을 명령한다
2. DMA 컨트롤러는 CPU 대신 장치 컨트롤러와 상호작용하며 입출력 작업을 수행한다
이때 DMA 컨트롤러는 필요한 경우 메모리에 직접 접근하여 정보를 읽거나 쓴다
3. 입출력 작업이 끝나면 DMA 컨트롤러는 CPU에 인터럽트를 걸어 작업이 끝났음을 알린다

#### 입출력 버스
CPU, 메모리, DMA 컨트롤러, 장치 컨트롤러가 모두 같은 버스를 공유하는 구성에서는 DMA를 위해 한 번 메모리에 접근할 때마다 시스템 버스를 두 번 사용하게 되는 부작용이 있다
이문제는 DMA 컨트롤러와 장치 컨트롤러들을 `입출력 버스`라는 별도의 버스에 연결하여 해결할 수 있다

입출력 버스에는 `PCI 버스`, `PCI Express(PCIe)버스` 등 여러 종류가 있다
여러 입출력장치들을 PCIe 버스와 연결해 주는 통로인 `PCIe 슬롯`을 통해 시스템 버스를 타고 CPU와 정보를 주고 받는다

![](https://velog.velcdn.com/images/ncookie/post/5fe5d99d-b4d1-4aa2-81ad-a93b0dd60d8e/image.png)