# 운영체제 
---
## CPU 스케줄링
---
### CPU 스케줄링 개요
```
운영체제가 프로세스들에게 공정하고 합리적으로 CPU 자원을 배분하는 것
```
CPU 스케줄링은 컴퓨터 성능과도 직결되는 중요한 문제이다
프로세스에게 현명하게 CPU를 배분하지 못하면 반드시 실행되어야 할 프로세스들이 실행되지 못하거나, 당장 급하지 않은 프로세스들만 주로 실행되는 등 무질서한 상태가 발생할 수도 있기 때문이다

---
### 프로세스 우선순위
프로세스 마다 운선순위를 가지고 있다
우선순위가 높은 프로세스란 빨리 처리해야하는 프로세스들을 의미한다
우선순위가 높은 프로세스에는 대표적으로 입출력 작업이 많은 프로세스가 있다

프로세스 종류마다 입출력장치를 이용하는 시간과 CPU를 이용하는 시간의 양에는 차이가 있다
비디오 재생이나 디스크 백업 작업을 담당하는 프로세스와 같이 입출력 작업이 많은 `입출력 집중 프로세스`와 복잡한 수학 연산, 컴파일, 그래픽 처리 작업을 담당하는 프로세스와 같이 CPU 작업이 많은 `CPU 집중 프로세스`도 있다

입출력 집중 프로세스는 실행 상태보다는 입출력을 위한 대기 상태에 더 많이 머무르게 된다
반대로 CPU 집중 프로세스는 대기 상태보다는 실행 상태에 더 많이 머무르게 된다
CPU 집중 프로세스는 CPU를 많이 사용해야 하는 프로세스이고, 입출력 집중 프로세는 그렇지 않은 프로세스인데, CPU 집중 프로세스와 입출력 집중 프로세스가 모두 동일한 빈도로 CPU를 사용하는 것은 비합리적이다

모든 프로세스가 CPU를 차례대로 돌아가며 사용하는 것보다 `각각의 상황에 맞게 CPU를 배분하는 것이 더 효율적`이다

상황에 맞게, 그리고 프로세스의 중요도에 맞게 프로세스가 CPU를 이용할 수 있도록 하기 위해 운영체제는 프로세스마다 `우선순위`를 부여한다

---
### 스케줄링 큐
PCB에 우선순위가 적혀 있다고는 하지만, CPU를 사용할 다음 프로세스를 찾기 위해 운영체제가 일이링 모든 프로세스의 PCB를 뒤적거리는 것은 비효율적이다
이는 비단 CPU 자원에만 국한된 상황이 아니다
운영체제가 매번 일일이 모든 PCB를 검사하여 먼저 자원을 이용할 프로새스를 결정하는 일은 매우 번거로울뿐더러 오랜 시간이 걸리는 일이다

그래서 운영체제는 프로세스들에게 `줄을 서서 기다릴 것`를 요구한다
무언가을 사용하고 싶어하는 프로새스들을 모두 줄 세우는 것이다
그리고 운영체제는 이 줄을 `스케줄링 큐`로 구현하고 관리한다
> 큐는 자료 구조 관점에서 보았을 때는 선입선출 자료 구조이지만, 스케줄링에서 이야기하는 큐는 `반드시 선입선출 방식일 필요는 없다`

운영체제가 관리하는 대부분의 자원은 큐로 관리된다
큐애는 다양한 종류가 있다
대표적인 큐로 `준비 큐`와 `대기 큐`가 있다
- 준비 큐 : CPU를 이용하고 싶은 프로세스들이 서는 줄
- 대기 큐 : 입출력장치를 이용하기 위해 기다리는 줄

운영체제는 PCB들이 큐에 삽입된 순서대로 프로세스를 하나씩 꺼내어 실행하되, 그중 `운선순위가 높은 프로세스`를 먼저 실행한다
대기 상태에 있는 프로세스도 마찬가지이다

---
### 선점형과 비선점형 스케줄링
- 선점형 스케줄링   
    ```
    하나의 프로세스가 자원을 사용하고 있을 때 다른 프로세스가 해당 자원을 빼앗을 수 있는 스케줄링
    ```
    프로세스가 CPU를 비롯한 자원을 사용하고 있더라도 운영체제가 프로세스로부터 자원을 강제로 빼앗아 다른 프로세스에 할당할 수 있는 스케줄링 방식이다
    어느 하나의 프로세스가 자원 사용을 독점할 수 없는 스케줄링 방식이다

    - 장점   
    어느 한 프로세스의 `자원 독점`을 막고 프로세스들에 골고루 자원을 배분할 수 있다는 장점이 있다
    - 단점   
    문맥 교환 과정에서 `오버헤드`가 발생할 수 있다

- 비선점 스케줄링
    ```
    빼앗을 수 없는 스케줄링
    ```
    하나의 프로세스가 자원 사용을 독점할 수 있는 스케줄링 방식이라고 할 수 있다
    만약 비선점형 스케줄링 방식으로 자원을 이용하려는 프로세스가 있다면 다른 프로세스들은 그 프로세스의 사용이 모두 끝날 때까지 기다려야 한다
    
    - 장점   
    문맥 교환에서 발생하는 오버헤드는 선점형 스케줄 보다 적다
    - 단점   
    모든 프로세스가 골고루 자원을 사용할 수 없다