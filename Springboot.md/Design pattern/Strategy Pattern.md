# Spring boot
---
## Design pattern
---
### Strategy Pattern
```
실행(런타임) 중에 알고리즘 전략을 선택하여 객체 동작을
실시간으로 바뀌도록 할 수 있게하는 행위 디자인 패턴
```
어떤 일을 수행하는 알고리즘이 여러가지 일때, 동작들을 미리 전략으로 정의함으로써 `손쉽게 전략`을 교체할 수 있는 , `알고리즘 변형`이 빈번하게 필요한 경우에 적합한 패턴이다

**전략 패턴은 `OPP`의 집합체**   
전략 패턴은 여러 객체 지향 문법 기법들인 SOLID 원칙의 `OPC 원칙`, `DIP원칙`, `합성(compositoin)`, `다형성(polymorphism)`, `캡슐화(encapsulation)` 등 OOP 기술들의 총 집합 버전이라고 보면 된다   

![](https://images.velog.io/images/y_dragonrise/post/01b02920-5e7d-4a90-b5be-7cdfe0f6091d/image.png)

- 동일 계열의 알고리즘군을 정의하고 -> `전략 구현체로 정의`
- 각각의 알고리즘을 캡슐화하여 -> `인터페이스로 추상화`

- 이들을 상호 교환이 가능하도록 만든다 -> `합성(composition)으로 구성`
- 알고리즘을 사용하는 클라이언트와 상관없이 독립적으로 -> `컨텍스트 객체 수정 없이`
- 알고리즘을 다양하게 변경할 수 있다 -> `메서드를 통해 전략 객체를 실시간으로 변경함으로써 전략을 변경`

---
### 장단점
**장점**   
- 새로운 전략을 추가하더라도 기존 코드를 `변경하지 않는다`

- 상속대신 `위임`을 사용할 수 있다
    - 상속은 하나 밖에 상속이 안되고, 상속을 강요하면 상속이 필요할 때 사용하지 못하고
    - 상위클래스가 변경되면 하위클래스가 영향을 받으니 좀 더 `구현`을 이용해서 `유연`해진다

- 런타임에 `전략`을 변경할 수 있다

**단점**   
- `복잡도`가 증가한다   
- 클라이언트가 `구체적인 전략`을 알아야 한다

---
### 특징
**사용시기**   
- 전략 알고리즘의 `여러 버전 또는 변형`이 필요할 때 `클래스화`를 통해 관리
- 알고리즘 코드가 노출되어서는 안되는 데이터에 `액세스`하거나 `데이터를 활용`할 때(`캡슐화`)
- 알고리즘의 동작이 런타임에 `실시간으로 교체` 되어야 할 때

**주의점**   
- 개발자는 적절한 전략 선택하기 위해 `전략 간의 차이점`을 파악하고 있어야한다(복잡도 ↑)
- 만일 어플리케이션 특성이 알고리즘이 많이 않고 자주 변경되지 않는다면, 새로운 클래스와 인터페이스를 만들어 프로그램을 복잡하게 만들 이유가 없다

---