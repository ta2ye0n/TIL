# Spring boot
---
## Design Pattern
---
### Command Pattern
```
실행될 기능 캡슐화함으로써 주어진 여러 기능을 실행할 수 있는 
재사용성이 높은 클래스를 설계하는 패턴
```
이벤트가 발생했을 때 실행될 기능이 다양하면서도 변경이 필요한 경우에 이벤트를 발생시키는 클래스를 변경하지 않고 재사용하고자 할 때 유용하다

실행될 기능을 `캡슐화`함으로써 기능의 실행을 요구하는 호출자(Invoker)클래스와 실제 기능을 실행하는 수진자 (Reciver) 클래스 사이의 `의존성을 제거`한다

---
### 패턴 구조
![](https://images.velog.io/images/ayoung0073/post/3f6fbd8a-61d1-4bee-b4d7-aac07238234c/image.png)
```
- Command : execute() 메서드를 선언하여 Receiver에서 수행할 연산을 구체화하는 방법을 정의

- ConcreteCommand : Command 인터페이스를 구현하고 이를 통해 Receiver 클래스의 함수를 호출
    - 일반적으로 execute() 함수에서 수행

- Invoker : 사용자의 요청을 Command 객체로 변환하며, 객체를 저장하고 실행하는 역할

- Receiver : 요청을 수행하는데 필요한 실제 작업을 구현한 클래스
```
---
### 사용시기
- 이벤트가 발생했을 때 `실행될 기능이 다양`하면서도 `변경이 필요`한 경우

- 커맨드 발생 시점을 사용자가 `커스터마이징`해야 할 때
- 여러 커맨드를 조합하여 하나의 커맨드처럼 사용할 필요가 있을때
- 커맨드 `실행 취소, 재실행` 등의 기능을 구현해야 할때

---
### 장단점
**장점**   
- `SRP 원칙`을 잘 지킨다   
작업을 수행하는 객체와 작업을 요청하는 객체를 분리하기 때문이다

- `OCP 원칙`을 잘 지킨다    
기존 코드 없이 새로운 리시버와 새로운 커맨드 추가가 가능하기 때문이다
- 커맨드 단위의 별도의 액션 등이 가능하고 커맨드 상속 및 조함을 통해 더 정교한 커맨드를 구현할 수 있다

**단점**   
- 전체적으로 `이해가 필요`하고 `복잡한 설계구조`를 가진다

- 작업을 수행하는 `비용`이 높아질 수도 있다

---