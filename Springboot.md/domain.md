# Domain
```
실세계에서 사건이 발생하는 집합
```
> 도메인과 객체의 차이   
객체 - 추상화 또는 구체화할 수 있는 특정 요소만을 표현   
도메인 - 사용자가 사용하는 모든 것을 설명

---
## DDD(Domain-Driven Design)
```
여러가지 도메인들이 상호작용하며, 비즈니스 도메인별로 나누어 설계하는 것
```
### 핵심 목표
`High cohesion`, `Loosly coupling`으로 각각의 `도메인은 서로 철저히 분리`되고, `높은 응집력과 낮은 결합도`로 `변경과 확장에 용이한 설계`을 얻게된다

---
### DDD의 계층구조 (Layered Architecture)
```
계정이 나뉘어져 있는 아키텍쳐

주된 목표
각각의 layer는 하나의 관심사에만 집중할 수 있도록 하는 것
```

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FdXLkOR%2FbtrvDQM9EfZ%2FMQ1xCqwjpXsNGQnS1jc0Gk%2Fimg.png)
Layered Architecture를 올바르게 구현하기 위한 두가지 중요한 규칙   
1. 위의 계층에서 아래 계층에는 접근이 가능하지만 아래에서 위로는 불가능한 것을 기본으로 한다
2. 한 계층의 관심사와 관련된 어떤 것도 다른 계층에 배치되어서는 안된다
---
#### Presentation Layer (표현 계층) (Controller)
- 사용자 요청에 대해 해석하고 응답하는 일을 책임지는 계층

- 사용자에게 UI를 제공하거나 클라이언트에 응답을 다시 보내는 역할을 하는 모든 클래스가 포함된다
- Client로 부터 request를 받고 response를 return 하는 API 정의

#### Application Layer (응용 계층) (Service)
- 비즈니스 로직을 정의하고 정상적으로 수행될 수 있도록 도메인 계층과 인프라스트럭쳐 계층을 연결해주는 역할을 하는 계층

- 이 계층은 많은 정보를 가지고 있지 않게 유지하는 것이 중요
- 실질적인 데이터의 상태 변화 등의 처리는 도메인 계층에서 진행할 수 있도록 위임하는 것이 중요

**ApplicationLayer에 포함하는 기능들**   
1. 트랜잭션의 단위
2. DTO 변환
3. 엔티티 조회 / 저장
    > 단순하게 말하면 Entity를 찾고 (Repository), 변경 내용을 저장하는 기능(Persistence)을 호출한다 (구현은 Infra layer)
4. 사용자 인증 / 인가
    > URL만으로 판단이 어렵거나, DB내의 데이터와 대조해봐야 알 수 있는 경우 (데이터 존재 여부, 중복 여부 등)
5. 파라미터 검증
    > 주로 요청 방식에 따라 달라지는 '형식'에 대한 검증을 하고, application layer에서는 '논리적'인 오류를 검증한다

#### DomainLayer (도메인 계층) (Model)
- 비즈니스 규칙, 정보에 대한 실질적인 도메인에 대한 정보를 가지고 있으며 이 모든 것을 책임지는 계층

- Entity를 활용하여 도메인 로직이 실행되며, 업무 상황을 반영하여 상태를 제어하는 역할에 집중하는 계층

#### Infrastructure Layer (인프라 계층) (Repository)
- 외부와의 통신(DB, 메시징 시스템 등)을 담당하는 계층
- 해당 계층에서 얻어온 정보를 응용 계층 또는 도메인 계층에 전달하는 것이 주 역할이다

**각각의 도메인들을 위와 같은 Layer로 철처히 부리해서 만드는 것이 DDD(Domain-Driven Design)의 핵심 설계 방식이다**

---
### Layered Architecture의 장점
- 각 레이어를 looselhy coupling 된 형태로 구축하면서, 각각 자신의 관심사에만 집중할 수 있다
    > loose Coupling (느슨한 결합) :  하나의 콤포넌트의 변경이 다른 콤포넌트들의 변경을 요구하는 위험을 줄이는 것을 목적으로 하는 시스템에서  콤포넌트 간의 내부 의존성을 줄이는 것을 추구하는 디자인 목표
- 핵심 비즈니스 로직을 순수하게 유지함으로써 유지보수와 확장성 측면에서 이득을 얻을 수 있다
- 각 레이어에 서로 다른 추상화 수준을 가진 상태와 행동을 위치시킴으로써 코드 재사용성을 높일 수 있다

---
### Layered Architecture의 단점
- 서비스가 커질수록 복잡도가 증가하여 확장성이 떨어진다 

- 레이어로 분리된 관심사 외에 다른 관심사가 생길 경우 패키지 분리 및 코드 배치가 어렵다