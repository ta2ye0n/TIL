# Java
---
## 상속(inheritance)
```
클래스에 기능을 추가하거나 재정의하여 새로운 클래스를 정의하는 것

객체 지향 프로그래밍을 구성하는 중요한 특징 중 하나
```

상속을 이용하면 기존에 정의되어 있는 클래스의 필드와 메소드를 물려받아, 새로운 클래스를 생성할 수 있다

---
### 상속의 대상
자식 클래스가 부모 클래스로부터 상속을 받게 되면 `부모 클래스의 필드와 메서드`를 물려받게 된다   
단, 접근제어자인 `private`을 갖는 필드나 메소드는 상속이 불가하고, `패키지가 다를 경우` 접근제어자가 `default`인 경우도 상속이 불가능하다

---
### 상속의 장점
```
1. 기존에 작성된 클래스 재활용
2. 자식 클래스 설계시 중복되는 멤버를 미리 부모 클래스에 작성해 놓으면, 자식 클래스에서는 해당 멤버를 작성하지 않아도 됨
3. 클래스 간의 계층적 관계를 구성함으로써 다형성의 문법적 토대를 마련
4. 유지 보수가 편리
```
---
### 상속 방법(선언)
`extends` 키워드 사용 
```java
class 자식클래스명 extends 부모 클래스명 {...}
```

자바에서는 자식 클래스가 여러 부모로부터 `다중 상속을 받는 것은 불가능`하다   
-> 1개의 부모 클래스로부터의 `단일 상속만 허용`된다     
하지만 부모 클래스는 여러 개의 자식 클래스에게 상속이 가능하다 

---
### super(), super
**super**   
```
부모 클래스로부터 상속받은 필드나 메소드를 자식 클래스에서 참조하는 데 사용하는 참조 변수

부모 클래스의 멤버와 자식 클래스의 멤버 이름이 같을 경우 super 키워드를 사용하여 구별할 수 있다
```

this와 마찬가지로 super 참조 변수를 사용할 수 있는 대상도 `인스턴스 메소드`뿐이며, 클래스 메소드에서는 사용할 수 없다

**super()**   
```
부모 클래스의 생성자를 호출할 때 사용

자식 클래스의 인스턴스를 생성하면, 해당 인스턴스에는 자식 클래스의 고유 멤버뿐만 아니라 부모 클래스의 모든 멤버까지도 포함되어 있다
따라서 부모 클래스의 멤버를 초기화하기 위해서는 자식 클래스의 부모 클래스의 생성자까지 호출해야만 한다
```
> 메서드의 가장 윗줄에 있어야한다

자바 컴파일러는 부모 클래스의 생성자를 명시적으로 호출하지 않는 모든 자식 클래스의 생성자 첫줄에 자동으로 `super()`를 추가하며, 부모 클래스의 멤버를 `초기화`할 수 있도록 해준다
> 생성자가 하나도 정의되어 있지 않아야만, 자동으로 기본 생성자를 추가해준다   
매개변수가 있는 생성자를 하나라도 선언한다면, 부모 클래스에는 기본 생성자가 자동으로 추가되지 않는다

---
### 메소드 오버라이딩(Overriding)
```
상속 관계에 있는 부모 클래스에서 이미 정의된 메소드를 자식 클래스에서 같은 시그니쳐를 갖는 메소드로 다시 정의하는 것
```

**조건**   
- 재정의할 부모의 메소드와 `동일한 메소드명, 리턴 타입, 매개 변수 리스트`로 작성해야 한다
- 부모 클래스의 메소드보다 접근 제어자를 `더 좁은 범위로 변경`할 수 없다
- 부모 클래스의 메소드보다 더 큰 범위의 예외를 선언할 수 없다
---
### final
```
final 키워드가 클래스나 메소드에 붙게 되면, 각각 상속할 수 없고, 오버라이딩 할 수 없다
```
> final -> 최종적이며, 수정될 수 없음을 의미( 상수 선언시에 많이 볼 수 있다)

---
### Object 클래스
자바에서 object 클래스는 모든 클래스의 `부모 클래스`가 되는 클래스이다   
따라서 자바의 모든 클래스는 자동으로 Object 클래스의 모든 필드와 메소드를 상속받게 된다    
즉, 자바의 모든 클래스는 별도로 extends 키워드를 사용하여 Object 클래스의 상속을 명시하지 않아도 `Object 클래스의 모든 멤버를 자유롭게 사용`할수 있다

---