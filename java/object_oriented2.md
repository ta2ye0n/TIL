# 객체지향 문법
---
### 필드
클래스 메소드 vs 인스턴스 메소드   
- 인스턴스 별로 다르게 동작해야 한다면 인스턴스 메소드
- static 메소드는 객체 생성이나 유틸리티 관련에서 사용될 때가 있다
- 되도록 인스턴스 메소드를 사용한다
> 인스턴스 메소드와 클래스 메소드를 잘 이해하려면 필드(field)에 대한 이해가 필요하다

**필드(field)**   
- 클래스가 가지는 속성을 자바 언어에서는 필드라고 말한다   
- 다른 언어에서는 멤버 변수라고 말하는 경우도 있다   
- 필드는 어떤 키워드와 함게 사용하느냐 따라서 사용방법이 달라진다   
- static이라는 키워드가 함께 사용되는 필드는 클래스 필드, 함께 사용되지 않는 필드는 인스턴스필드라고 한다

필드 선언 방법
``` java
[접근제한자][static][final] 타입 필드명 [= 초기값];

대괄호안에 있는 건 생략 가능
접근제한자는 public, protected, 아무것도 없는 경우(default), private이 올 수 있다
필드명은 식별자 규칙을 따른다 
다만 필드의 첫번째 글자는 소문자로 시작하는 것이 프로그래머 관례이다
타입(type)은 기본형(boolean, byte, char, short, int, long, float, double)과 
참조타입(class,인터페이스, 배열) 등이 나올 수 있다
초기값이 없을 경우에는 참조형일 경우 null로 boolean형일 경우는 false로 
나머지 기본형은 모두 0으로 초기화 된다
```

필드 선언 예제
``` java
String name;
// String은 참조 타입 name 변수는 아무것도 참조하지 않고 null 값을 가진다
String address = "경기도 고양시";
// address는 "경기도 고양시"라는 문자열 인스턴스를 참조한다
public int age = 50;
// int age는 기본형 타입으로 메모리 4바이트의 저장공간이 잡히고 그 안에 50을 저장하게 된다
protected boolean flag; 
// boolean flag는 기본형 타입으로 메모리 1바이트를 차지하고 아무 값도 넣어주지 않으면 false를 가지게 된다

// 접근제한자가 생략된 name, address는 디폴트 접근 제한자가 설정되었다고 한다
```

문자열은 자바에서 특수하게도 new를 사용하지 않고도 인스턴스를 생성할 수 있다 되도록 new를 사용하지 않고 큰 따옴표로 묶어서 인스턴스를 참조하는 것이 좋다
> 자바 개발자들이 String은 너무 자주 사용하기 때문에 큰따옴표로 묶는 것만으로도 인스턴스를 사용할 수 있게 해준것이다   
String은 final 클래스이며, Object를 상속받고 3개의 인터페이스를 구현한다고 정의되어있다   
String은 여러 개의 생성자를 가지고 있다 매개변수의 타입이 다르거나 개수가 다른 생성자를 여러 개 가지고 있다   
String은 또한 다양한 메소드를 가지고 있다 String이 가지고 있는 length()라는 메소드는 String이 가지는 문자열의 길이를 리턴한다

- length() 메소드
```
String이 가지는 문자열의 길이를 리턴한다
```
아무것도 참조하고 있지 않은 상태에서 사용하면 `NullPointException`이라는 오류가 발생하면서 프로그램은 종료되게 된다

래퍼런스 타입은 반드시 인스턴스를 참조해야만 사용할 수 있다   
가장 실수하기 쉬운게 아무것도 참조하지 않는 변수를 사용하는 것이다
> 디버그 모드로 실행하면 어떤 값에 문제가 있어서 오류가 발생하는지 알 수 있다

- **static 필드**   
```  java
static한 필드는 클래스명.필드명 형식으로 사용한다

static 필드를 클래스 변수라고도 얘기한다
```

```
인스턴스를 만들기 전에 JVM이 하는 일이 있다
JVM은 클래스가 CLASSPATH에 있는지 찾아보고 클래스를 찾을 수 없으면 
ClassNotFoundException 오류를 발생한다
클래스 정보 자체는 정적이라고 말한다 클래스 정보 자체는 실행되는 것이 아니기 때문이다
사용하는 SSD나 하드디스크에 저장되어 있던 클래스를 읽어 들여서 자바가 사용할 수 있는 메모리 영역에 그 정보를 올리게 된다
클래스 정보를 메모리에 올리게 되는데, 이때 클래스에 static 필드가 있는지 살펴본다
static 필드를 가지고 있으면 JVM은 CLASSPATH에서 클래스를 찾고 클래스 정보를 메모리에 올린다
클래스 정보를 읽어 들일 때 static한 필드는 정적 영역에 따로 저장된다
인스턴스를 만들지 않아도 클래스를 JVM이 읽어 들일때 static한 필드는 메모리에 따로 올라간다
```

- 클래스 메소드에서 인스턴스 필드를 사용하지 못하는 이유
```
클래스 메소드 안에서 인스턴스 필드를 사용하려고 하면 컴파일 오류가 발생한다

그 이유는 메모리에 생성되는 시점이 다르기 때문이다 클래스 메소드는 인스턴스가 없어도 사용 가능하지만 인스턴스 필드는 인스턴스가 있어야만 사용하기 때문이다

클래스 메소드가 실행되는 시점에서는 인스턴스 필드가 메모리에 없으니까 사용할 수 없다고 컴파일 오류가 발생한다

클래스 메소드(static 메소드) 안에서는 클래스 필드(static 필드)만 사용할 수 있다
```    
```
메소드는 매개변수를 받고, 결과를 처리한 후 어떤 값을 리턴할 수 있다 그리고 메소드는 클래스에서 선언된 필드를 사용할 수 도 있다
메소드는 그 메소드가 포함된 클래스의 필드를 사용할 수 있고 인스턴스 메소드는 가지고 있는 클래스가 인스턴스가 되야지만 사용할 수 있다

인스턴스 필드는 인스턴스를 만들어야만 사용가능하다

인스턴스 필드, 인스턴스 메소드이기 때문에 인스턴스를 생성하지 않고 사용하면 컴파일 오류가 발생한다(non-static 변수라는 오류 메시지)
인스턴스 필드와 인스턴스 메소드는 클래스명.필드명, 클래스명.메소드명()과 같은 형태로 사용할 수 없다

JVM은 클래스 정보를 읽어 들일 때 클래스가 가지고 있는 클래스 필드와 클래스 메소드를 사용 가능하도록 메모리에 올리게 된다

인스턴스 필드와 인스턴스 메소드는 인스턴스를 생성한 후, 그 인스턴스를 참조하는 참조 변수를 이용해서 사용해야 한다 인스턴스가 만들어 지지 않으면 사용하지 못한다
```

- main메소드보다 먼저 실행되는 static 블록   
클래스 필드는 바로 값을 초기화 할 수도 있고 static 블록에서 초기화 할수 있다
```
소스를 컴파일하고 java로 실행하면, JVM은 CLASSPATH에서 클래스를 찾게 된다 이 클래스를 읽어 들여서 그 정보를 메모리에 올리게 된다

main 메소드가 실행되기 전에 static 블록 안의 코드가 실행되는 것을 이용한 프로그래밍을 할 수도있다
```

- 자바 메모리
```
PermGen - Java 7에서 사용되는 메모리 영역

Metaspace - Java 8부터 사용되는 메모리 영역
- Java Heap은 JAM이 관리하는 메모리 영역, Native Memory는 운영체제가 관리하는 메모리 영역
```
![](https://miro.medium.com/v2/resize:fit:513/0*rKZvTnuUkEc5LoXW.jpg)
> Java7까지는 JVM이 관리하는 메모리 영역인 PermGen에 클래스 정보가 올라갔었다 Java8부터는 Metaspace라는 영역에 올라간다

- 소스코드, 클래스 파일 자체는 정적이다   
    - 동적인 것들은 실행되면서 생성되는 것들을 말한다
    - 클래스 정보 자체는 정적이다 JVM은 사용해야할 클래스의 정보를 읽어들여서 메모리에 올리게 된다
    > 클래스가 저장된 HDD(하드디스크)나 SSD는 Ram 보다 속도가 느리기 때문에 매번 보조 기억장치에서 읽어들이는 건 성능을 저하시키는 원이 된다 클래스 정보는 처음 사용될 때 메모리에 그 정보를 올리고 필요할 때 마다 사용하게 된다

- 클래스 로딩
```
클래스는 로딩될 때 메사스페이스에 클래스가 로딩된다

Java 7까지는 non-heap 영역에 저장되었고, Java 8부터는 Heap 영역에 저장된다
```
> static한 필드는 클래스가 로딩될 때 딱 한번 메모리에 올라가고 초기화 된다

- static 정보 저장
```
Java 7전까지는 non-heap 영역에 저장되었고, Java 8부터는 Heap 영역에 저장된다
```
> 인스턴스는 더 이상 참조되는 것이 없을 때, 나중에(언제가 될지는 모른다 보통 메모리가 부족할 때) 가비지 컬랙션(Garbage Collection)이 된다

- **추상화**
```
중요한 것은 남기고, 불필요한 것은 제거한다
```
```
객체 지향에서도 추상화는 굉장히 중요하다
프로그램을 만들 때 비지니스 영역(도메인 영역)에 맞도록 추상화를 해야한다 먼 미래까지 대비해서 클래스를 만들 필요는 없다
우리에게 필요한 것이 있으면 그것만 가지도록하고, 기능도 필요한 것만 가지도록 한다
```

- **캡슐화(encapsulation)**   
```
관련된 것을 잘 모아서 가지고 있는 것을 캡슐화(encapsulation)라고 말한다
관련된 것을 잘 모아서 가지고 있을 수록 응집도(Cohesion)가 높다고 표현한다
```
> 은닉화와도 관련이 있다

- 좋은 객체
```
응집도는 높고 결합도(Coupling)는 낮다
```
> 응집도가 높다는 것
>> 관련된 기능을 잘 모아서 가지고 있는 것

 - 좋은 객체를 만들게 될때 이 두가지 법칙
    - 객체를 만들 땐 관련된 기능을 잘 모아서 가지고 있어야하고, 객체와 객체간의 결합도는 낮춰야 한다
> 자바는 클래스 지향이 아닌 객체 지향이라는 거 기억

- **다형성(Polymorphism)**   
```
프로그램 언어의 다형성은 그 프로그래밍 언어의 자료형 체계의 성질을 나타내는 것으로, 프로그램 언어의 각 요소들(상수, 변수, 식, 오브젝트, 함수, 메소드 등)이 다양한(type)에 속하는 것이 허가 되는 성질을 가리킨다
반댓말을 단형성으로, 프로그램 언어의 각 요소가 한가지 형태만 가지는 성질을 가리킨다
```

예시
``` java
System.out.println()
- println은 "인자를 출력하고 줄바꿈을 한다" 라는 기능
- 여기에서 인자는 int, float, double, String등이 될 수 있다
- 중요한건 메소드 이름이 같다는 거다 왜 메소드 이름이 같다는 것이 중요할까?

System이 가지고 있는 out. 이 out은 PrintStream 타입이다
PrintStream 클래스는 println() 메소드를 가진다

int를 출력하든 double을 출력하든 메소드 이름은 println으로 같다
프로그램을 설계한다는 것은 이름을 잘 짓는 것이다
값이 뭐가 되든 출력 후 줄 바꿈 한다라는 의미이니 어렵게 메소드 이름을 다르게 지을 필요가 없다
```

- **다형성 - 메소드 오버로딩(Overloading)**   
    - 메소드의 이름은 같고 매개변수의 갯수나 타입이 다른 함수를 정의하는 것을 의미한다
    - 리턴값만을 다르게 갖는 오버로딩은 작성 할 수 없다

어떤 메소드가 실행될지는 JVM이 실행하면서 동적으로 결정하게 된다
어떤 타입을 출력하느냐에 따라서 메소드 이름이 달라진다면 사용자는 외워야 할 메소드 수가 늘어나서 힘들어 질 것이다

> 객체를 만들 땐 나는 어렵게 만들어도, 사용하는 사람은 쉽게 쓸 수 있도록 만들어야 한다

- 패키지
```
클래스는 패키지를 이용하여 관련된 클래스를 관리한다 자바에서 패키지는 폴더와 거의 같은 기능을 제공한다고 생각하면 된다

클래스 수가 늘어나면 관련 있는 클래스끼리 잘 모아 놓는 것이 중요하다

자바는 패키지를 이용해 관련 있는 클래스를 관리하게 된다

package를 지정하는 문장은 첫 번째 줄에 위치한다
```
> 패키지는 폴더라고 생각하면 쉽다

- 패키지 이름 규칙
```
패키지 이름은 도메인 이름을 거꾸로 적은 후에 프로젝트 이름을 붙여서 만든다
```
관련된 클래스를 모으는 기준
-  음악파일도 음악 듣는 성향에 따라 폴더를 다르게 만드는 것처럼 소프트웨어는 아키텍처(구조)를 따라 만든다

패키지 구조는 아키텍처에 따라 달라진다 아키텍처를 정하는 사람을 아키텍트라고 한다
아키텍처가 잘 정의되면 아키텍처에 맞게 패키지를 작성하는 방법도 정의된다

- 패키지 선언 방법
```
package 패키지명;

주석문이나 빈줄을 제외하고 가장 윗줄에 위와 같은 형식으로 선언한다
```

- 패키지 이름을 작성할 때 도메인 이름을 거꾸로 적는 이유   
```
앞으로 오픈소스(open source)를 많이 사용하게 될것이다
혹은 회사에서 다른 사람이 만든 소스코드를 가져다 사용하는 경우도 있다 그렇게 되면 다른 사람이 만든 클래스 중에 내가 만든 클래스와 이름이 같은 경우가 있다
폴더에는 같은 이름의 파일이 여러 개 있을 수 없다

패키지 이름이 같고 클래스 이름까지 같으면 충돌이 발생한다
거꾸로 적은 도메인 + 프로젝트 이름(모듈이름) 형태로 하면 충돌이 잘 안나겠구나 라고 생각한 것이다
```

- 패키지가 정의된 클래스 컴파일 하기
    - javac -d 경로명 *java
    - -d 옵션을 사용

- import   
패키지를 사용할 땐 import 문장을 사용한다
```
import 패키지명.클래스명;
```
import는 JVM에게 어떤 패키지의 클래스를 사용하게 할 것인지 알려주는 역할을 한다 메모리에 올리거나 그런 일을 하는 것이 아니다   
동일한 이름의 클래스가 여러 패키지에 있을 수 있기 때문에 잘 구분해서 import하여 사용해야 한다   
같은 이름의 클래스를 사용할 땐, 하나는 import를 해서 사용하고 또 다른 하나는 클래스명 앞에 패키지 명까지 붙여서 사용해야한다