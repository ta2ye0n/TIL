# 객체지향 문법
---
### 필드
클래스 메소드 vs 인스턴스 메소드   
- 인스턴스 별로 다르게 동작해야 한다면 인스턴스 메소드
- static 메소드는 객체 생성이나 유틸리티 관련에서 사용될 때가 있다
- 되도록 인스턴스 메소드를 사용한다
> 인스턴스 메소드와 클래스 메소드를 잘 이해하려면 필드(field)에 대한 이해가 필요하다

**필드(field)**   
- 클래스가 가지는 속성을 자바 언어에서는 필드라고 말한다   
- 다른 언어에서는 멤버 변수라고 말하는 경우도 있다   
- 필드는 어떤 키워드와 함게 사용하느냐 따라서 사용방법이 달라진다   
- static이라는 키워드가 함께 사용되는 필드는 클래스 필드, 함께 사용되지 않는 필드는 인스턴스필드라고 한다

필드 선언 방법
``` java
[접근제한자][static][final] 타입 필드명 [= 초기값];

대괄호안에 있는 건 생략 가능
접근제한자는 public, protected, 아무것도 없는 경우(default), private이 올 수 있다
필드명은 식별자 규칙을 따른다 
다만 필드의 첫번째 글자는 소문자로 시작하는 것이 프로그래머 관례이다
타입(type)은 기본형(boolean, byte, char, short, int, long, float, double)과 
참조타입(class,인터페이스, 배열) 등이 나올 수 있다
초기값이 없을 경우에는 참조형일 경우 null로 boolean형일 경우는 false로 
나머지 기본형은 모두 0으로 초기화 된다
```

필드 선언 예제
``` java
String name;
// String은 참조 타입 name 변수는 아무것도 참조하지 않고 null 값을 가진다
String address = "경기도 고양시";
// address는 "경기도 고양시"라는 문자열 인스턴스를 참조한다
public int age = 50;
// int age는 기본형 타입으로 메모리 4바이트의 저장공간이 잡히고 그 안에 50을 저장하게 된다
protected boolean flag; 
// boolean flag는 기본형 타입으로 메모리 1바이트를 차지하고 아무 값도 넣어주지 않으면 false를 가지게 된다

// 접근제한자가 생략된 name, address는 디폴트 접근 제한자가 설정되었다고 한다
```

문자열은 자바에서 특수하게도 new를 사용하지 않고도 인스턴스를 생성할 수 있다 되도록 new를 사용하지 않고 큰 따옴표로 묶어서 인스턴스를 참조하는 것이 좋다
> 자바 개발자들이 String은 너무 자주 사용하기 때문에 큰따옴표로 묶는 것만으로도 인스턴스를 사용할 수 있게 해준것이다   
String은 final 클래스이며, Object를 상속받고 3개의 인터페이스를 구현한다고 정의되어있다   
String은 여러 개의 생성자를 가지고 있다 매개변수의 타입이 다르거나 개수가 다른 생성자를 여러 개 가지고 있다   
String은 또한 다양한 메소드를 가지고 있다 String이 가지고 있는 length()라는 메소드는 String이 가지는 문자열의 길이를 리턴한다

- length() 메소드
```
String이 가지는 문자열의 길이를 리턴한다
```
아무것도 참조하고 있지 않은 상태에서 사용하면 `NullPointException`이라는 오류가 발생하면서 프로그램은 종료되게 된다

래퍼런스 타입은 반드시 인스턴스를 참조해야만 사용할 수 있다   
가장 실수하기 쉬운게 아무것도 참조하지 않는 변수를 사용하는 것이다
> 디버그 모드로 실행하면 어떤 값에 문제가 있어서 오류가 발생하는지 알 수 있다

- **static 필드**   
```  java
static한 필드는 클래스명.필드명 형식으로 사용한다

static 필드를 클래스 변수라고도 얘기한다
```

```
인스턴스를 만들기 전에 JVM이 하는 일이 있다
JVM은 클래스가 CLASSPATH에 있는지 찾아보고 클래스를 찾을 수 없으면 
ClassNotFoundException 오류를 발생한다
클래스 정보 자체는 정적이라고 말한다 클래스 정보 자체는 실행되는 것이 아니기 때문이다
사용하는 SSD나 하드디스크에 저장되어 있던 클래스를 읽어 들여서 자바가 사용할 수 있는 메모리 영역에 그 정보를 올리게 된다
클래스 정보를 메모리에 올리게 되는데, 이때 클래스에 static 필드가 있는지 살펴본다
static 필드를 가지고 있으면 JVM은 CLASSPATH에서 클래스를 찾고 클래스 정보를 메모리에 올린다
클래스 정보를 읽어 들일 때 static한 필드는 정적 영역에 따로 저장된다
인스턴스를 만들지 않아도 클래스를 JVM이 읽어 들일때 static한 필드는 메모리에 따로 올라간다
```

- 클래스 메소드에서 인스턴스 필드를 사용하지 못하는 이유
```
클래스 메소드 안에서 인스턴스 필드를 사용하려고 하면 컴파일 오류가 발생한다

그 이유는 메모리에 생성되는 시점이 다르기 때문이다 클래스 메소드는 인스턴스가 없어도 사용 가능하지만 인스턴스 필드는 인스턴스가 있어야만 사용하기 때문이다

클래스 메소드가 실행되는 시점에서는 인스턴스 필드가 메모리에 없으니까 사용할 수 없다고 컴파일 오류가 발생한다

클래스 메소드(static 메소드) 안에서는 클래스 필드(static 필드)만 사용할 수 있다
```    
```
메소드는 매개변수를 받고, 결과를 처리한 후 어떤 값을 리턴할 수 있다 그리고 메소드는 클래스에서 선언된 필드를 사용할 수 도 있다
메소드는 그 메소드가 포함된 클래스의 필드를 사용할 수 있고 인스턴스 메소드는 가지고 있는 클래스가 인스턴스가 되야지만 사용할 수 있다

인스턴스 필드는 인스턴스를 만들어야만 사용가능하다

인스턴스 필드, 인스턴스 메소드이기 때문에 인스턴스를 생성하지 않고 사용하면 컴파일 오류가 발생한다(non-static 변수라는 오류 메시지)
인스턴스 필드와 인스턴스 메소드는 클래스명.필드명, 클래스명.메소드명()과 같은 형태로 사용할 수 없다

JVM은 클래스 정보를 읽어 들일 때 클래스가 가지고 있는 클래스 필드와 클래스 메소드를 사용 가능하도록 메모리에 올리게 된다

인스턴스 필드와 인스턴스 메소드는 인스턴스를 생성한 후, 그 인스턴스를 참조하는 참조 변수를 이용해서 사용해야 한다 인스턴스가 만들어 지지 않으면 사용하지 못한다
```

- main메소드보다 먼저 실행되는 static 블록   
클래스 필드는 바로 값을 초기화 할 수도 있고 static 블록에서 초기화 할수 있다
```
소스를 컴파일하고 java로 실행하면, JVM은 CLASSPATH에서 클래스를 찾게 된다 이 클래스를 읽어 들여서 그 정보를 메모리에 올리게 된다

main 메소드가 실행되기 전에 static 블록 안의 코드가 실행되는 것을 이용한 프로그래밍을 할 수도있다
```

- 자바 메모리
```
PermGen - Java 7에서 사용되는 메모리 영역

Metaspace - Java 8부터 사용되는 메모리 영역
- Java Heap은 JAM이 관리하는 메모리 영역, Native Memory는 운영체제가 관리하는 메모리 영역
```
![](https://miro.medium.com/v2/resize:fit:513/0*rKZvTnuUkEc5LoXW.jpg)
> Java7까지는 JVM이 관리하는 메모리 영역인 PermGen에 클래스 정보가 올라갔었다 Java8부터는 Metaspace라는 영역에 올라간다

- 소스코드, 클래스 파일 자체는 정적이다   
    - 동적인 것들은 실행되면서 생성되는 것들을 말한다
    - 클래스 정보 자체는 정적이다 JVM은 사용해야할 클래스의 정보를 읽어들여서 메모리에 올리게 된다
    > 클래스가 저장된 HDD(하드디스크)나 SSD는 Ram 보다 속도가 느리기 때문에 매번 보조 기억장치에서 읽어들이는 건 성능을 저하시키는 원이 된다 클래스 정보는 처음 사용될 때 메모리에 그 정보를 올리고 필요할 때 마다 사용하게 된다

- 클래스 로딩
```
클래스는 로딩될 때 메사스페이스에 클래스가 로딩된다

Java 7까지는 non-heap 영역에 저장되었고, Java 8부터는 Heap 영역에 저장된다
```
> static한 필드는 클래스가 로딩될 때 딱 한번 메모리에 올라가고 초기화 된다

- static 정보 저장
```
Java 7전까지는 non-heap 영역에 저장되었고, Java 8부터는 Heap 영역에 저장된다
```
> 인스턴스는 더 이상 참조되는 것이 없을 때, 나중에(언제가 될지는 모른다 보통 메모리가 부족할 때) 가비지 컬랙션(Garbage Collection)이 된다

- **추상화**
```
중요한 것은 남기고, 불필요한 것은 제거한다
```
```
객체 지향에서도 추상화는 굉장히 중요하다
프로그램을 만들 때 비지니스 영역(도메인 영역)에 맞도록 추상화를 해야한다 먼 미래까지 대비해서 클래스를 만들 필요는 없다
우리에게 필요한 것이 있으면 그것만 가지도록하고, 기능도 필요한 것만 가지도록 한다
```

- **캡슐화(encapsulation)**   
```
관련된 것을 잘 모아서 가지고 있는 것을 캡슐화(encapsulation)라고 말한다
관련된 것을 잘 모아서 가지고 있을 수록 응집도(Cohesion)가 높다고 표현한다
```
> 은닉화와도 관련이 있다

- 좋은 객체
```
응집도는 높고 결합도(Coupling)는 낮다
```
> 응집도가 높다는 것
>> 관련된 기능을 잘 모아서 가지고 있는 것

 - 좋은 객체를 만들게 될때 이 두가지 법칙
    - 객체를 만들 땐 관련된 기능을 잘 모아서 가지고 있어야하고, 객체와 객체간의 결합도는 낮춰야 한다
> 자바는 클래스 지향이 아닌 객체 지향이라는 거 기억

- **다형성(Polymorphism)**   
```
프로그램 언어의 다형성은 그 프로그래밍 언어의 자료형 체계의 성질을 나타내는 것으로, 프로그램 언어의 
각 요소들(상수, 변수, 식, 오브젝트, 함수, 메소드 등)이 다양한(type)에 속하는 것이 허가 되는 성질을 가리킨다
반댓말을 단형성으로, 프로그램 언어의 각 요소가 한가지 형태만 가지는 성질을 가리킨다
```

예시
``` java
System.out.println()
- println은 "인자를 출력하고 줄바꿈을 한다" 라는 기능
- 여기에서 인자는 int, float, double, String등이 될 수 있다
- 중요한건 메소드 이름이 같다는 거다 왜 메소드 이름이 같다는 것이 중요할까?

System이 가지고 있는 out. 이 out은 PrintStream 타입이다
PrintStream 클래스는 println() 메소드를 가진다

int를 출력하든 double을 출력하든 메소드 이름은 println으로 같다
프로그램을 설계한다는 것은 이름을 잘 짓는 것이다
값이 뭐가 되든 출력 후 줄 바꿈 한다라는 의미이니 어렵게 메소드 이름을 다르게 지을 필요가 없다
```

- **다형성 - 메소드 오버로딩(Overloading)**   
    - 메소드의 이름은 같고 매개변수의 갯수나 타입이 다른 함수를 정의하는 것을 의미한다
    - 리턴값만을 다르게 갖는 오버로딩은 작성 할 수 없다

어떤 메소드가 실행될지는 JVM이 실행하면서 동적으로 결정하게 된다
어떤 타입을 출력하느냐에 따라서 메소드 이름이 달라진다면 사용자는 외워야 할 메소드 수가 늘어나서 힘들어 질 것이다

> 객체를 만들 땐 나는 어렵게 만들어도, 사용하는 사람은 쉽게 쓸 수 있도록 만들어야 한다

- 패키지
```
클래스는 패키지를 이용하여 관련된 클래스를 관리한다 자바에서 패키지는 폴더와 거의 같은 기능을 제공한다고 생각하면 된다

클래스 수가 늘어나면 관련 있는 클래스끼리 잘 모아 놓는 것이 중요하다

자바는 패키지를 이용해 관련 있는 클래스를 관리하게 된다

package를 지정하는 문장은 첫 번째 줄에 위치한다
```
> 패키지는 폴더라고 생각하면 쉽다

- 패키지 이름 규칙
```
패키지 이름은 도메인 이름을 거꾸로 적은 후에 프로젝트 이름을 붙여서 만든다
```
관련된 클래스를 모으는 기준
-  음악파일도 음악 듣는 성향에 따라 폴더를 다르게 만드는 것처럼 소프트웨어는 아키텍처(구조)를 따라 만든다

패키지 구조는 아키텍처에 따라 달라진다 아키텍처를 정하는 사람을 아키텍트라고 한다
아키텍처가 잘 정의되면 아키텍처에 맞게 패키지를 작성하는 방법도 정의된다

- 패키지 선언 방법
```
package 패키지명;

주석문이나 빈줄을 제외하고 가장 윗줄에 위와 같은 형식으로 선언한다
```

- 패키지 이름을 작성할 때 도메인 이름을 거꾸로 적는 이유   
```
앞으로 오픈소스(open source)를 많이 사용하게 될것이다
혹은 회사에서 다른 사람이 만든 소스코드를 가져다 사용하는 경우도 있다 그렇게 되면 다른 사람이 만든 클래스 중에 내가 만든 클래스와 이름이 같은 경우가 있다
폴더에는 같은 이름의 파일이 여러 개 있을 수 없다

패키지 이름이 같고 클래스 이름까지 같으면 충돌이 발생한다
거꾸로 적은 도메인 + 프로젝트 이름(모듈이름) 형태로 하면 충돌이 잘 안나겠구나 라고 생각한 것이다
```

- 패키지가 정의된 클래스 컴파일 하기
    - javac -d 경로명 *java
    - -d 옵션을 사용

- import   
패키지를 사용할 땐 import 문장을 사용한다
```
import 패키지명.클래스명;
```
import는 JVM에게 어떤 패키지의 클래스를 사용하게 할 것인지 알려주는 역할을 한다 메모리에 올리거나 그런 일을 하는 것이 아니다   
동일한 이름의 클래스가 여러 패키지에 있을 수 있기 때문에 잘 구분해서 import하여 사용해야 한다   
같은 이름의 클래스를 사용할 땐, 하나는 import를 해서 사용하고 또 다른 하나는 클래스명 앞에 패키지 명까지 붙여서 사용해야한다

- 상속
```
○○은 ○○이다. ○○는 ○○의 종류 중 하나다. 라고 표현할 수 있다면 이것은 상속 관계라고 말할 수 있다 상속 관계는 is a관계 혹은 kind of 관계라고 말하기도 한다
```
○○는 ○○의 종류 중 하나다
- 일반화 시킨다
![](https://blog.kakaocdn.net/dn/cDksNj/btrpyihBoZx/tXFnceyqBGrnsOrZXAq3S0/img.png)

일반화란 자식 클래스들을 부모클래스로 부를 수 있는 것
여러 종류의 객체를 하나의 이름으로 부를 수 있는것

**상속 = 일반화 + 확장**
```
상속이란 일반화와 확장이라는 개념을 합한 것이라고 생각하면 된다 부모클래스를 상속받는다는 것은 부모가 가지고 있는 것을 자식이 물려받아 사용할 수 있다는 것을 의미한다
```

> 상속은 굉장히 강한 결합이다 상속은 반드시 써야 할때만 쓰고 되도록 사용 안하는게 좋다
>> 결합도는 낮추고, 응집도는 높이는 것이 좋다고 했다 상속은 가장 강한 결합이니 잘못 상속받으면 타격이 너무 크기 때문이다

- 상속 선언 방법
```
[접근제한자][abstract | final] class 클래스명 extends 부모클래스명 {
    ............
} -> 클래스 블록
```

아무것도 상속받지 않으면 자동으로 java.lang.Object를 상속 받는다
- 모든 클래스는 Object의 자손이다
    - 모든 클래스의 최상위 클래스는 Object가 된다

- 상속 - 부모타입으로 자식 인스턴스 참조하기   
부모 타입으로 자손 타입을 참조할 수 있다

예시
```
버스는 자동차다

Car car = new Bus();

참조타입과 인스턴스 타입이다르다
Bus인스턴스가 만들어졌는데 실제 참조는 Car타입으로 하나는 의미
이 문법이 컴파일 오류가 발생하지 않으려면 Bus는 Car의 자식이나 자손이어야 한다

Bus bus = new Bus();
위와 같이 인스턴스를 생성해도 되는데, 참조타입을 부모 타입으로 사용하는 이유
참조변수의 타입만 보면 아 이런 메소드만 사용하겠구나 라고 알게 되니 코드를 분석할 때 쉬워진다
```
> 문법만 맞게 코드를 작성했다고 해서 프로그래밍을 잘 했다고 볼 수 없다

- 다형성 - 메소드 오버라이딩(Overriding)
    - over + ride = 올라타다?
    - 상위 클래스의 메소드를 하위 클래스가 재정의 하는 것
    - 부모 클래스가 가지고 있는 메소드를 자식 클래스에서 재정의 하는 것
    - 메소드의 이름은 물론 파라메터의 갯수가 타입도 동일해야 하며, 주로 상위 클래스의 동작을 상속 받은 하위 클래스에서 변경하기 위해 사용된다

> 상속 관련된 문법중엔 오버라이드가 있는데 오버라이드는 "올라타다"라는 의미가 있다 부모가 가지고 있는 메소드와 리턴 타입, 매개변수, 메소드 이름이 같은 경우이다 
>>겹쳐봤을때 하나로 보이는 경우

**메소드가 오버라이딩 되면 무조건 자식의 메소드가 실행된다(중요)**   
```java
예시

Car도 public void run() 메소드를 가지고 있고, Bus도 public void run()메소드를 가지고 있다면

Car car = new Bus();
car.run;

Bus의 run() 메소드가 실행된다
```
> IntelliJ에서는 ctrl + enter(윈도우), cmd + enter(맥)을 누르면 메뉴가 열리는데 이 메뉴에서 Override Methods를 누르면 쉽게 메소드를 오버라이딩 할 수 있다

- 형변환
```java
예시

Bus는 Car를 상속한다 Bus인스턴스를 생성하고 Car타입의 참조 변수 c1이 Bus인스턴스를 참조한다

Car c1 = new Bus();
Bus b2 = (Bus)c1;

위의 코드는 c1이 참조하는 인스턴스를 b2도 참조하라는 의미이다
하나의 인스턴스를 b2,c1이 참조하게 된다
가능한 이유는 c1이 참조하는 인스턴스가 실제로는 Bus인스턴스이기 때문이다
c1이 참조하는 인스턴스가 Bus가 아니었다면 b2가 참조할때 Excption(오류)가 발생할 수도 있다
c1이 참조하는 Bus 인스턴스를 Bus타입으로 변환해서 b2가 참조하게 하라는 의미다

후손 인스턴스를 조상 타입의 인스턴스를 조상 타입의 참조 변수로 참조하는 것은 당연히 가능하다

c1은 Car타입이기 때문에 Bus 타입의 b2로 참조하게 하려면(Bus)를 붙여줘서 c1이 참조하는 것이 
(Bus)로 참조할 수 있어 프로그래머인 내가 보증해라는 의미로 붙여줘야 한다
```

**필드, 메소드의 오버라이딩 할 때 주의점**
```
필드는 Type을 따라가고, 메소드는 오버라이딩된 자식의 메소드가 실행된다
```
메소드는 오버라이딩되면 무조건 자식의 메소드가 실행된다   

필드가 오버라이딩 되서 자식의 값이 사용되면 부모 클래스를 만든 사람이 예상하지 못한 결과가 출력될 것이다     
그렇기 때문에 필드는 타입을 따라간다

- 메소드 오버라이딩만 기억한다
    - 정보 은닉(information hiding)은 객체지향의 중요한 기법이다 중요한 필드는 은닉하고, 필드는 메소드를 통해서만 접근해서 사용하도록 한다
    > 메소드가 오버라이딩 되면 무조건 자식의 것이 실행된다는 걸 기억하기

객체 지향 프로그래밍을 할 때 정보 은닉이란 개념이 있다
되도록 필드는 숨겨야 한다

필드를 은닉한다는 것은 외부에서 필드를 직접 접근하지 못하도록 해야 한다는 의미이다

필드를 직접 접근하지 않고 메소드를 통해 사용해야 한다 필드는 메소드를 통해서 사용할 수 있도록 코드를 작성해야 한다   
이러한 개념을 정보 은닉이라 하고 객체 지향 문법 중 접근 지정자를 사용해서 은닉하게 된다

**setter, getter 메소드**
> public int price 예시!!

필드를 직접 접근 하는 것을 정보 은닉 관점에서 안 좋다고 했다 외부에서 접근하지 못하도록 public 접근제한자를 private 접근제한자로 수정한다

private으로 변경하면 외부에서 price를 직접 사용하던 부분에서 컴파일 오류가 생긴다
private한 필드는 접근하지 못하기 때문에, private 필드를 사용할 수 있는 메소드를 제공해야한다

```
private한 필드를 접근하기 위해 제공하는 메소드를 setter, getter라고 한다
```
ctrl+ Enter (윈도우), cmd+Enter(맥)을 누르면 "Getter and Setter"라고 하는 메뉴를 통해 자동으로 생성할 수 있다

메소드가 길어지면 메소드에서 선언된 지역 변수인지 필드인지 착각할 수 있기 때문에 인스턴스 필드를 사용할 때는 `this.price`라고 적어 줄 수도 있다

```
this는 내 자신 인스턴스를 말하는 키워드이다
```
static메소드는 인스턴스가 생성이 되지 않아도 사용가능하다 했다 메모리에 생성되는 시점이 다르기 때문에 static 메소드에서는 this를 사용할 수 없다

getter 메소드를 이용해 값을 가공해 반환할 수 있다

> spring 프레임워크에서는 setter, getter을 프로퍼티라고 한다   
자바 공부할때는 프로퍼티라는 용어가 사용되지 않는다

**toString(), equals(), hashCode() 메소드**

Object가 오버라이딩하라고 제공하는 메소드
- toString()
- equals() & hashCode()

```
부모타입의 변수로 자식인스턴스를 참조할 수 있다
조상타입의 변수로 후손 인스턴스를 창조할 수 있다
Ex) Car c1 = new Bus();
    Car c2 = new 이층버스(); -> 이층버스는 Car의 자손이다

아무것도 상속 받지 않으면 오브젝트를 상속 받기 때문에
Object o1 = new Car();
Object o2 = new Bus();
이렇게 써도 오류가 안남

System.out.println(Car); // println(object s) - Object로 참조할 수 있는 것은 무엇이든 받을 수 있다

System.out.println(o1.toString()); == System.out.println(o1);
```
```
equals() - 값이 같은지 보는 것
사용자가 기준을 정해줘야하고 오버라이딩해서 사용해야 한다

값이 같다? -> 인스턴스가 같나? 같은지 보려면 기준을 정해줘야 한다

예시) 책장에 있는 책 - 제목이 같으면 같은 책이다

hash를 잘 구현하려면 - 값이 같은지 확인하거나 hashcode 만들거나
```