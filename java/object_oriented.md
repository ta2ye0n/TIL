# 객체지향 문법
---
### 객체지향 프로그래밍
```
객체 지향 프로그래밍(Object_Oriented Programming, OOP)은 컴퓨터 프로그래밍의 패러다임 중 하나이다. 
객체 지향 프로그래밍은 컴퓨터 프로그램을 명령어의 목록으로 보는 시각에서 
벗어나 여러 개의 독립된 단위, 즉 "객체" 들의 모임으로 파악하고자 하는 것이다.
각각의 객체는 메시지를 주고 받고, 데이터를 처리할 수 있다.
```
>  클래스(class), 오브젝트(object), 인스턴스(instance), 참조형 변수(Reference Variable) 이러한 단어들을 사용하는데 매번 헷갈리면 안된다   
각각의 단어들이 무슨 의미인지 알아나가야 하는것이 객체 지향 프로그래밍 공부의 시작이다   
>> 유사 개념   
클래스 = 설계도면   
오브젝트 = 인스턴스 = 설계도면을 보고 실제 만들어진 것(실재 존재하는 것)   
참조형 변수 = 오브젝트(인스턴스)를 사용하기 위해 선언  (참조되지 않은 인스턴스 = 쓰레기)   

- 객체 지향   
객체 지향 프로그래밍은 내가 만들 객체 들이 메모리에 올라간 후, 어떻게 서로 관계를 맺고 동작할 지가 정리돼야 할수 있다

- 객체지향의 핵심은 **메시징**
```
의도는 "메시징"이다
훌륭하고 성장 가능한 시스템을 만들기 위한 핵심은 모듈 내부의 속성과 행동이
어떤가보다 모듈이 어떻게 커뮤니 케이션하는 가에 달려있다

Alan Curtis Kay
(객체 지향 프로그래밍의 선구자)
```
- 메시징   
어떤 객체가 어떤 객체에 메소드를 호출하는 것
> 객체가 어떤 행동을 하는 유일한 이유는 이 객체의 메소드를 다른 객체가 호출 했을 때이다

- 객체의 책임
```
객체의 메소드가 다른 곳에서 호출되었을때 동작하게 된다
요청을 처리하기 위해 객체가 수행하는 행동을 책임이라고 한다
객체는 책임을 가지고 있다
자율적인 책임의 특징은 객체가 어떻게 해야 하는가가 아니라 무엇을 해야하는가를 설명한다는 것이다
```
### 클래스
```
- 필드(Field)와 메소드 (Method)를 가진다
- 필드는 클래스의 속성이라고 말할 수 있다
- 메소드는 클래스의 기능이라고 말할 수 있다
```
- 클래스 선언 방법
``` sql
1. 첫 문자가 문자나 '_','$'의 특수문자로 시작되어야 한다. 숫자로 시작할 수 없다
2. 첫 문자가 아니라면, 문자나 '-''$'의 특수문자 그리고 숫자로 구성될 수 있다. 
   JDK8에서는 한 글자로 이뤄진 변수는 예약어로 정의되어 있기 때문에 사용할 수 없다
3. 자바의 예약어는 식별자로 사용할 수 없다
4. 자바의 식별자는 대소문자를 구분한다
5. 식별자 길이는 제한이 없고 공백은 포함할 수 없다

접근제한자 class 클래스이름{
    필드들;
    생성자들;
    메소드들;
}

* 접근제한자 - public, protected, private, 없음(default)
```
- 프로그래머들간의 관례
```
1. 클래스 명은 대문자로 시작한다
2. 단어와 단어가 만날 경우 2번째 단어의 시작은 대문자로 한다
예를 들어 'Hello'와 'World'란 단어를 이용하여 클래스 이름을 만든다면 'HeelWorld'가 된다. 낙타의 등처럼 오르락 내리락 한다고 하여 낙타표기법 카멜 표기법이라고 한다
```
### 메소드
- 메소드 선언 방법
``` sql
[접근제한자][static] 리턴type 메소드이름([매개변수,...]){
    실행문
    ...
} -> 메소드 블록({})
대괄호 부분은 생략 가능하다는 의미
```
- 메소드 이름 짓는 규칙 = 클래스 이름 짓는 규칙
> 메소드 이름은 소문자로 시작하도록 짓는 것이 관례이다
```
- 매개변수 (parameter)
- 전달인자 (argument)
매개변수는 메소드의 정의부분에 나열되어 있는 변수들을 의미하며, 전달인자는 메소드를 호출할때 전달되는 실ㄹ제 값을 의미한다
```
```
클래스 메소드 : static이 붙은 메소드
보통의 메소드는 메모리에 올라가 있는 것만 사용가능하다 클래스 메소드는 인스턴스를 생성하지 않아도 사용할 수 있다

즉, 클래스 메소드는 인스턴스를 생성하지 않아도 메모리에 올라가 있다는 것을 의미한다
```
- new 연산자   
```
new 연산자를 사용하면 메모리에 인스턴스가 생성된다
new를 사용해야 클래스가 메모리에 올라가서 인스턴스가 될 수 있다
인스턴소로 메모리에 올라가야 오브제트라 부를 수 있고 사용할 수 있다
```
> 필요한 개수만큼 잘 만들어야한다 new연산자를 많이 사용하면 메모리에 인스턴스가 많아지고 프로그램이 죽게된다 그래서 메모리 관리를 잘 해야 한다
- 인스턴스 생성   
객체 지향 프로 그래밍에서 인스턴스 생성은 굉장히 중요하다
``` sql
인스턴스를 만드는 3가지 방법

1. new연산자와 생성자를 이용하여 인스턴스를 만드는 방법
(가장 많이 쓰이는 방법)
2. 클래스 로더를 이용하는 방법
3. 메모링 있는 인스턴스를 복제(clone)하여 만드는 방법

첫번째 방법{
클래스명 변수명 = new 클래스명();

참조타입 참조변수 = new연산자 생성자
}
```

- **메소드 선언방법**
```
매개변수는 메소드에 전달하는 값
반환값은 메소드가 외부로 반환하는 값
메소드에 들어가는 값은 매개 변수, 메소드에서 나오는 것은 리턴(return)한다라고 표현한다
public 다음의 void는 리턴 하지 않는다는 의미이고, 괄호안에 아무것도 없으면 매개변수를 받지 않는다는 의미이다
매개 변수가 없고 반환값이 있을 경우 마지막에 return을 해야한다

메소드는 0개 이상의 매개 변수를 받아 들인 후, 코드를 실행하고 어떤 결과를 return 할 수 있다
```

- UML 표기법
```
+ -> public이라는 의미
+ 그다음에 나오는 것 -> 메소드 이름
괄호 안에 있는 것 -> 매개 변수
콜론(;) 뒤 -> 리턴 type
```

- 메소드가 실행될 때    
자바 소스는 javac 명령을 통해 컴파일 된다    
java 명령이 JVM(Java Virtual Machine)이라고 이야기 한다   
JVM이 클래스를 실행해준다

java는 클래스를 어디서 찾아서 실행할까?
```
예를 들어 VendingMachineMain이라는 클래스가 있다고 할때

javac를 이용해 컴파일을 하면, 소스 파일이 있던 곳에 class 파일이 생성된다

java VendingMachineMain이라고 실행하면 JVM은 어디서 찾을가
JVM이 클래스를 실행하려면, 일단 클래스를 찾아야 한다
JVM CLASSPATH 경로에서 크래스를 찾는다
CLASSPATH에 .(점)이 있을 경우 현재 경로에서 클래스를 찾을 수 있게 된다

java VendingMachineMain을 실행하면 CLASSPATH에서 VendingMachineMain 클래스를 찾게된다

VendingMachineMain 클래스를 JVM은 읽어 들이고 읽어 들인 클래스 정보를 PERM이라는 메모리 영역에 저장한다

IntelliJ는 소스를 컴파일 하고 out/production/ 프로젝트 폴더아래에 class 파일을 생성한다 해당 폴더를 IntelliJ는 CLASSPATH로 인식하게 해준다

PERM이라고 부르는 메모리 영역에 읽어 들인 클래스 정보를 저장한다
(클래스 자제에 대한 정보가 PERM 영역에 올라가게 됨)

클래스 정보가 PERM 영역에 올라가게 되면, JVM은 해당 클래스가 어떤 static 메소드를 가지고 있는지 인스턴스 메소드를 가지고 있는지 모두 알게 된다

JVM은 프로그램 시작 점인 main 메소드를 찾게 된다 그리고 main 메소드를 실행하게 된다

Java Stack이라고 불리는 메모리 영역에 실행된 메소드 정보가 올라가게 된다

Stack은 FILO 자료구조라고 한다 먼저 들어간 자료가 가장 나중에 나온다는 의미아

JVM은 PERM 메모리에 올라가 있는 VendingMachineMain 클래스에서 main 메소드를 찾는다

main 메소드를 찾고, 해당 메소드 정보를 Java Stack에 넣어준다

Java Stack에 저장된 메소드 실행 정보 하나를 스택 엔트리(Stack Entry)라고 한다

main 메소드 안에 선언된 변수들은 스택 엔트리에 저장된다 이러한 변수를 로컬(local)변수라고 한다

main 메소드가 실행되면 , Heap 메모리에 String 배열 인스턴스가 만들어지고 이 인스턴스를 args 변수가 참조하게 된다

스택엔트리에는 프로그램 카운트라고 해서 몇번째 줄을 실행하고 있는지 정보도 기억하고 있다 다음 줄을 실행할 때마다 프로그램 카운트는 증가하게 된다

실행종료가 되면 해당 메소드의 실행 정보를 담고 있는 스택 엔트리는 자바 스택에서 제거가 된다

메소드 안에 선언된 변수를 지역 변수라 하고, 지역 변수는 메소드가 종료되면 사라진다
같은 메소드를 동시에 여러 번 호출한다면 그 메소드 안의 지역변수는 각각 다른 영역에 저장되어 사용된다
동시에 메소드가 호출되도 문제가 없다
메소드에서 클래스 안에 선언된 변수를 사용할 경우엔 문제가 발생할 수 있다
```